#include <array>
#include <cmath>

template <int M>
class Chebyshev {
 public:
  template <class T>
  using array_t = std::array<T, M + 1>;

  const static int order = M;

  Chebyshev()
      : alphas_(alphas()), roots_(roots()), poly_samples_(polynomial_samples())
  {
  }

  template <typename T>
  void fill_coefficients_tensor(const T *const eval, T *coef)
  {
    constexpr int32_t size{M + 1};
    constexpr double norm{size * size * size};
    std::fill(coef, coef + (size * size * size), 0);

    const double *const chebS = &poly_samples_[0][0];

    // Generated by the Tensor Algebra Compiler (tensor-compiler.org)
    // coef(i, j, k) = norm * alphas(i) * alphas(j) * alphas(k) *
    //                 chebS(i, lambda) * chebS(j, mu) * chebS(k, nu) *
    //                 eval(lambda, mu, nu)
    for(int32_t ialphas = 0; ialphas < size; ialphas++) {
      double ti = alphas_[ialphas] / norm;
      for(int32_t lambdachebS = 0; lambdachebS < size; lambdachebS++) {
        int32_t pchebS2 = ialphas * size + lambdachebS;
        double tlambda = ti;
        double tlambda0 = chebS[pchebS2];
        for(int32_t jalphas_ = 0; jalphas_ < size; jalphas_++) {
          int32_t pcoef2 = ialphas * size + jalphas_;
          double tj = tlambda * alphas_[jalphas_];
          double tj0 = tlambda0;
          for(int32_t muchebS = 0; muchebS < size; muchebS++) {
            int32_t pchebS20 = jalphas_ * size + muchebS;
            int32_t peval2 = lambdachebS * size + muchebS;
            double tmu = tj;
            double tmu0 = tj0;
            double tmu1 = chebS[pchebS20];
            for(int32_t kalphas_ = 0; kalphas_ < size; kalphas_++) {
              int32_t pcoef3 = pcoef2 * size + kalphas_;
              double tnu = 0;
              for(int32_t nuchebS = 0; nuchebS < size; nuchebS++) {
                int32_t pchebS21 = kalphas_ * size + nuchebS;
                int32_t peval3 = peval2 * size + nuchebS;
                tnu += tmu * alphas_[kalphas_] * tmu0 * tmu1 * chebS[pchebS21] *
                       eval[peval3];
              }
              coef[pcoef3] = coef[pcoef3] + tnu;
            }
          }
        }
      }
    }
  }

  static array_t<int> alphas()
  {
    array_t<int> a;
    a.fill(2);
    a[0] = 1;

    return a;
  }

  static array_t<double> roots()
  {
    array_t<double> xs;
    for(int i = 0; i <= M; ++i) {
      xs[i] = -1 * std::cos(M_PI * (i + 0.5) / (M + 1));
    }

    return xs;
  }

  static array_t<array_t<double>> polynomial_samples()
  {
    array_t<array_t<double>> table;

    const auto xk = roots();

    for(int k = 0; k <= M; ++k) {
      table[0][k] = 1;
      if(M > 0) table[1][k] = xk[k];
    }

    for(int p = 2; p <= M; ++p) {
      for(int k = 0; k <= M; ++k) {
        table[p][k] = 2 * xk[k] * table[p - 1][k] - table[p - 2][k];
      }
    }

    return table;
  }

 private:
  array_t<int> alphas_;
  array_t<double> roots_;
  array_t<array_t<double>> poly_samples_;
};
