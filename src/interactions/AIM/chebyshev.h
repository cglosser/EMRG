#include <array>
#include <cmath>

template <int M>
class Chebyshev {
 public:
  template <class T>
  using array_t = std::array<T, M + 1>;

  const static int order = M;

  Chebyshev()
      : alphas_(alphas()), roots_(roots()), poly_samples_(polynomial_samples())
  {
  }

  template <typename T>
  void fill_coefficients_tensor(const int num_boxes,
                                const T *const eval,
                                T *const coef)
  {
    constexpr int32_t size{M + 1};
    constexpr double norm{1.0 / (size * size * size)};

    const double *const chebS = &poly_samples_[0][0];

    // Generated by the Tensor Algebra Compiler (tensor-compiler.org)
    // coef(box, i, j, k, dim) = norm * alphas(i) * alphas(j) * alphas(k) *
    //                           chebS(i, lambda) * chebS(j, mu) * chebS(k, nu)
    //                           * eval(box, lambda, mu, nu, dim)
    for(int32_t pcoef = 0; pcoef < (num_boxes * size * size * size * 3);
        pcoef++) {
      coef[pcoef] = 0;
    }
    for(int32_t boxeval = 0; boxeval < num_boxes; boxeval++) {
      double tbox = norm;
      for(int32_t ialphas = 0; ialphas < size; ialphas++) {
        int32_t pcoef2 = boxeval * size + ialphas;
        double ti = tbox * alphas_[ialphas];
        for(int32_t lambdachebS = 0; lambdachebS < size; lambdachebS++) {
          int32_t pchebS2 = ialphas * size + lambdachebS;
          int32_t peval2 = boxeval * size + lambdachebS;
          double tlambda = ti;
          double tlambda0 = chebS[pchebS2];
          for(int32_t jalphas = 0; jalphas < size; jalphas++) {
            int32_t pcoef3 = pcoef2 * size + jalphas;
            double tj = tlambda * alphas_[jalphas];
            double tj0 = tlambda0;
            for(int32_t muchebS = 0; muchebS < size; muchebS++) {
              int32_t pchebS20 = jalphas * size + muchebS;
              int32_t peval3 = peval2 * size + muchebS;
              double tmu = tj;
              double tmu0 = tj0;
              double tmu1 = chebS[pchebS20];
              for(int32_t kalphas = 0; kalphas < size; kalphas++) {
                int32_t pcoef4 = pcoef3 * size + kalphas;
                double tk = tmu * alphas_[kalphas] * tmu0 * tmu1;
                for(int32_t nuchebS = 0; nuchebS < size; nuchebS++) {
                  int32_t pchebS21 = kalphas * size + nuchebS;
                  int32_t peval4 = peval3 * size + nuchebS;
                  double tnu = tk * chebS[pchebS21];
                  for(int32_t dimeval = 0; dimeval < 3; dimeval++) {
                    int32_t peval5 = peval4 * 3 + dimeval;
                    int32_t pcoef5 = pcoef4 * 3 + dimeval;
                    coef[pcoef5] = coef[pcoef5] + tnu * eval[peval5];
                  }
                }
              }
            }
          }
        }
      }
    }
  }

  static array_t<int> alphas()
  {
    array_t<int> a;
    a.fill(2);
    a[0] = 1;

    return a;
  }

  static array_t<double> roots()
  {
    array_t<double> xs;
    for(int i = 0; i <= M; ++i) {
      xs[i] = -1 * std::cos(M_PI * (i + 0.5) / (M + 1));
    }

    return xs;
  }

  static array_t<array_t<double>> polynomial_samples()
  {
    array_t<array_t<double>> table;

    const auto xk = roots();

    for(int k = 0; k <= M; ++k) {
      table[0][k] = 1;
      if(M > 0) table[1][k] = xk[k];
    }

    for(int p = 2; p <= M; ++p) {
      for(int k = 0; k <= M; ++k) {
        table[p][k] = 2 * xk[k] * table[p - 1][k] - table[p - 2][k];
      }
    }

    return table;
  }

 private:
  array_t<int> alphas_;
  array_t<double> roots_;
  array_t<array_t<double>> poly_samples_;
};
